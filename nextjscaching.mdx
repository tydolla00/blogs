---
title: "What the heck is caching in React?… using NextJS"
description: "NextJS a framework based upon React introduces a revolutionary way of working with React components. With the latest release of Next 13 React Server Components are introduced into the React world. In this blog we tackle how Next optimizes and caches behavior in a React application."
date: "2023-10-20"
tags: ["nextjs", "new", "react", "tech"]
---

If you're new to React & NextJS like I was, you're probably overwhelmed with
all the incredible features it has to offer. Next 13 introduces the App Router,
a revolutionary way of working with Server Side Rendering.
It brings a myriad of brand new features including support for React Server Components, the React teams’ brand new invention!

<InfoBlock type="info">
  React Server Components are their own complex jenga game to understand.
  They're out of the scope of this blog, however Josh Comeau, a **very**
  experienced React dev wrote an amazing blog post about it! Check it out
  <BlueLink
    href="https://www.joshwcomeau.com/react/server-components/"
    text="here"
  />
</InfoBlock>

In short, React Server Components are components that run exclusively on the
server (…sort of). Which means you are able to directly access your backend system,
such as databases, file systems, and much more. It gives you the ability to write
backend code in React components and send fully hydrated HTML to the client.

Today we're talking about caching though. What is caching, how does it work in React, Next, and much more.

<H1 id="caching" text="What is Caching?" />

In order to understand caching, let's take a look at this graphic (without caching).

<GroceryGraphic />

<H2 id="truecaching" text="So how does it truly work?" />

When we make a request to an endpoint, we check our cache to see if the result
is stored in memory. On the first request this will be a <CodeBlock>`cache miss`</CodeBlock>. After
receiving the response, the response will be stored in memory (cached). Subsequent
requests to the same endpoint will be a <CodeBlock>`cache hit`</CodeBlock> and will never hit
the endpoint.

There are four key points of caching in Next.

<BulletList
  list={[
    "Request Memoization",
    "Data Cache",
    "Full Route Cache",
    "Router Cache",
  ]}
/>

Let's talk about Request Memoization.

<H2 id="request" text="Request Memoization" />

Request Memoization often referred to as deduplication, occurs when making
requests to the same endpoint. Using the native fetch api, requests hitting
the same endpoint will be cached and served from the cache.

<Example>
  You want to fetch the same data on two different pages. Without caching you
  would have to fetch the same data **twice** which is not very efficient. With
  request memoization we're able to cache & store that result in memory and any
  subsequent call will hit our cache instead of our endpoint. Let's take a look
  at a diagram from Vercel.
</Example>

<CustomImage src="requestmemoization.png" alt="Request Memoization" />

The first request is a <CodeBlock>`cache miss`</CodeBlock> because
there are none stored in memory. In the response the request is **set**
(stored in memory) and sent to the client. Now everytime we reach
the <CodeBlock>`item/1`</CodeBlock>
endpoint, it is a <CodeBlock>`cache hit`</CodeBlock>. Now the data cache is never
hit, reducing the load on the server and database.

What does this look like in code?

<Tabs stages={3} title="Fetch API" 
desc="The built in fetch API caches requests automatically, 
you can opt out of caching at a request level or a route level."
>
<Code lang="jsx">
```jsx
const getUsers = async () => {
  const res = await fetch("http://localhost:3000/api/test");
  console.log("Users fetched.")
  return res.json();
};

export default async function TestPage() {
  return (
    <>
      <Test />
      <SecondTest />
    </>

);
}

const Test = async () => {
const users: user[] = await getUsers();
return (

<>...</>
); };

const SecondTest = async () => {
const users: user[] = await getUsers();
return (

  <>...</>
); 
};
```
</Code>
How many times do you think "Users fetched" will be printed to the console?
</Tabs>

Here we have three server components all making requests to retrieve users from the database. However one of them makes request directly to the database. Can you guess what the log will be once this page renders? (Answer) Because the SecondTest component makes a direct call to the database it skips the cache because it is not using the fetch API.

That’s pretty unfortunate when we think about tools such as tRPC and ORM’s that make api routes useless because of server components ability to write database logic directly in the component. Luckily React has a cache function that can help us in this exact scenario! (Show code for next scenario) Now we can wrap our function that calls our DB in the cache function and voila we’ve achieved the same behavior as the fetch API.

<H2 id="datacache" text="Data Cache" />

The Data Cache works hand and hand with Request Memoization. A request is made to an endpoint on the first request it misses the cache and data cache. In the response it sets the data cache and memoizes the request. Now on every subsequent call to the same endpoint, the request will hit the cache and data cache returning the data from the data cache. (This could be a problem for invalid data.)

<CustomImage src="datacache.png" alt="Initial Data Cache Request" />
<CustomImage src="datacache2.png" alt="Time Based Revalidation Data Cache" />
<CustomImage src="datacache3.png" alt="On-Demand Revalidation Data Cache" />

You can opt out of caching if your data changes frequently. Such as apps like a Flight Tracker, food reservation, etc. Next provides many ways to invalidate data, read about it here.

[Building Your Application: Caching](https://nextjs.org/docs/app/building-your-application/caching#data-cache)

<H2 id="fullroutecache" text="Full Route Cache & Router Cache" />

Next Docs has amazing info about the full route cache and router cache. Read about them here If you want me to go over these in detail contact me and if I get enough requests I will update the section.

[Building Your Application: Caching](https://nextjs.org/docs/app/building-your-application/caching#full-route-cache)
